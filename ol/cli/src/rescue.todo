use std::{path::PathBuf, sync::Arc};

use diem_config::config::NodeConfig;
use diem_types::{access_path, write_set::WriteOp, transaction::{TransactionOutput, Version, WriteSetPayload}};
use diemdb::DiemDB;
use move_core_types::identifier::Identifier;
use move_vm_runtime::{move_vm::MoveVM, logging::NoContextLog};
use storage_interface::DbReaderWriter;
use anyhow::*;
use move_cli::on_disk_state_view::OnDiskStateView;

use diem_vm::{DiemVM};

// What I want to do:
// 1) take a snapshot of an epoch.
// 2) load a fresh database from it.
// 3) submit the management "RemoveValidator" transaction.
// 4) only then, start the nodes.

// From Runtian Z

// 1. You need to put your system in a sync-only mode to make sure no more txn could be committed.
// 2. Manually append one Transaction::GenesisTransaction  to the db on 2/3 of nodes
// 3. Resume the system
// For step 2 there are two parts:1
// 1. generate the raw blob for Transaction with diem-writeset-generator tool
// 2. commit the transaction to db via db-bootstrapper tool

// fn test_apply_write(path: PathBuf) -> anyhow::Result<()> {
//     let n = NodeConfig::default();

//     let (_, db_rw) = DbReaderWriter::wrap(
//         DiemDB::open(
//             &n.storage.dir(),
//             false, /* readonly */
//             n.storage.prune_window,
//             n.storage.rocksdb_config,
//         )
//         .expect("DB should open."),
//     );

//     let vm = MoveVM::new();
//     let mut sess = vm.new_session(&db_rw);

//     sess.execute_function(
//         &module_id,
//         &fun_name,
//         ty_args,
//         args,
//         &mut gas_status,
//         &context,
//     )?;

//     Ok(())
// }

// fn get_db(node_config: NodeConfig) -> (Arc<DiemDB>, DbReaderWriter) {
//     DbReaderWriter::wrap(
//         DiemDB::open(
//             &node_config.storage.dir(),
//             false, /* readonly */
//             node_config.storage.prune_window,
//             node_config.storage.rocksdb_config,
//         )
//         .expect("DB should open."),
//     )
// }


// from language/diem-tools/transaction-replay/src/lib.rs
fn save_write_sets(o: &TransactionOutput, state_view: OnDiskStateView) -> Result<()> {
    // let state_view = OnDiskStateView::create(&self.build_dir, &self.storage_dir)?;
    for (ap, op) in o.write_set() {
        let addr = ap.address;
        match ap.get_path() {
            access_path::Path::Resource(tag) => match op {
                WriteOp::Deletion => state_view.delete_resource(addr, tag)?,
                WriteOp::Value(bytes) => state_view.save_resource(addr, tag, bytes)?,
            },
            access_path::Path::Code(module_id) => match op {
                WriteOp::Deletion => state_view.delete_module(&module_id)?,
                WriteOp::Value(bytes) => state_view.save_module(&module_id, bytes)?,
            },
        }
    }
    for event in o.events() {
        state_view.save_contract_event(event.clone())?
    }
    Ok(())
}

// from language/diem-tools/transaction-replay/src/lib.rs

pub fn execute_writeset_at_version(
    build_dir: PathBuf,
    storage_dir: PathBuf,
    version: Version,
    payload: &WriteSetPayload,
    save_write_set: bool,
) -> Result<TransactionOutput> {
    let state_view = OnDiskStateView::create(build_dir, storage_dir)?;
    let vm = DiemVM::new(&state_view);
    let cache = diem_vm::data_cache::StateViewCache::new(&state_view);
    let log_context = NoContextLog::new();
    let sequence_number = match self
        .debugger
        .get_account_state_by_version(diem_root_address(), version)?
    {
        Some(account) => account
            .get_account_resource()?
            .ok_or_else(|| anyhow!("Diem root account doesn't exist"))?
            .sequence_number(),
        None => bail!("Diem root account blob doesn't exist"),
    };
    let txn_data = diem_vm::transaction_metadata::TransactionMetadata {
        sequence_number,
        sender: diem_types::account_config::diem_root_address(),
        ..Default::default()
    };

    let (_, output) = vm
        .execute_writeset_transaction(&cache, &payload, txn_data, &log_context)
        .map_err(|err| format_err!("Unexpected VM Error: {:?}", err))?;
    if save_write_set {
        save_write_sets(&output, state_view)?;
    }
    Ok(output)
}
