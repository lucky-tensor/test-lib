use crate::executor::FakeExecutor;
use crate::account::{Account, AccountData, lbr_currency_code, AccountTypeSpecifier};
use crate::redeem_setup::{redeem_txn};
use miner::delay;
use libra_types::transaction::TransactionStatus;
use libra_types::vm_error::{VMStatus, StatusCode};
use hex;

#[test]
fn submit_proofs_transaction() {
    // TODO: This is using the Fake Executor, like all the other e2e tests. Is there a way to use a libra-swarm node?
    let mut executor = FakeExecutor::from_genesis_file();

    let account = Account::new_genesis_account(libra_types::on_chain_config::config_address() );
    let sequence_number = 10u64;
    let sender = AccountData::with_account(
        account,
        1_000_000,
        lbr_currency_code(),
        sequence_number,
        AccountTypeSpecifier::Empty
    );

    executor.add_account_data(&sender);

    println!("address:{:?}", sender.address() );

    // let initialization_output = executor.execute_and_apply(
    //     // TODO: Describe what is happening here. What are we initializing?
    //     redeem_initialize_txn(&sender.account(), sequence_number)
    // );
    // assert_eq!(
    //     initialization_output.status(),
    //     &TransactionStatus::Keep(VMStatus::new(StatusCode::EXECUTED))
    // );

    // test data for the VDF proof, using easy/test difficulty
    // This assumes that it is a FIRST Proof, (genesis proof)
    // and it doesn't neet to match a previously sent proof.
    // effectively only a genesis ceremony will use this transaction.
    // Other miner onboarding will be done with the onboarding transaction.

    // This test uses Alice's genesis proof, to be used in a genesis ceremony.
    let challenge = hex::decode("1796824cdcc3ab205c25f260e15dc6705942d356f114089d4a46f2f3b0b15b52000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000304c20746573746e65746400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000050726f74657374732072616765206163726f737320746865206e6174696f6e").unwrap();
    let difficulty = 100;
    // Generate solutions with cd ./verfiable-delay/ cargo run -- -l=4096 aa 100
    // the -l=4096 is important because this is the security paramater of 0L miner.
    let proof_computed = delay::do_delay(&challenge);

    let proof = hex::decode("004102e5a40aa610d88964f2fb650511370811440577cd4cd643321f494accd05e10f5183cdb155b98f519e24619fd12a06bb12d9377c03998cb2f06a2b88485b2fc33704f632f518a7b821500cf5c6ee4e3748768af0ca25240f02041845e0d74975d82e6679996244d3bb41c0c36b520eea0ad11918ec44bff83a392d2e4fb7bc5c022275fc4ba242fa4c2503756a004ab262aeda9fac49b92521e2d6a96ab3b9d2fc0c3906da8ba3e87f4b249f81e9dc8cc879019bdffa716a878c9c73ea406fc60597b29f3f503cd9d293017a37cdec80b30f8bd95c6f1a67b7e1afe97a1f7fb4eed3a1e56cbf13c7f034c5373849008df4c6dafd92df0de5421b123a5839800087a8004a1a0e78ca4e0aa50760bc77e8dd00526aed9fa272541f1476ae5476bd520c72694ded1de34a672bdca451e8809d15d98910921e28ee313186e77726a428204672f66b873f35463d78570f126329c0541a5c1af1fb18b429be150fd1de9498d18717b09178a41aa15fd6fa8d7b6737d730fe87ef4ab875ec2459f8b97c604fc6f999d2c1df563e550ba247e5d7318319fcb0c22e39a3bc2d8b782d8fad912652fc151a99af0f4a28311050d77d75a1651d08d7a45676238765bab161c15648c4dd601eab92d169702f5a951b332845e87942ea48b453c177c51fa73e64d67544857f69d342ecd0ebf1e73ed57d7de1f780a9f01ceaa95b586f60ba2a300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001").unwrap();

    assert_eq!(proof_computed, proof.to_vec());

    let tower_height = 1u64;
    
    //run the transaction script
    let output = executor.execute_and_apply(
        // build the transaction script binary.
    redeem_txn(
        &sender.account(), 
        sequence_number,
        challenge.to_vec(),
        difficulty,
        proof.to_vec(),
        tower_height)
    );

    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(VMStatus::new(StatusCode::EXECUTED))
    );
}
