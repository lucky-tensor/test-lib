#!/usr/bin/env python3
# Copyright 2018 Chia Network Inc and Block Notary Inc
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# and limitations under the License.

# Generates `constants.rs`
import sys, subprocess
def generate(f):
    def odd_primes_below_n(n):
        sieve = [True] * (n//2)
        q = int(n ** 0.5)
        # Double-check the float computation with int math
        assert q * q <= n
        q += 1
        assert q * q > n
        for i in range(3, q, 2):
            if sieve[i // 2]:
                sieve[i * i // 2::i] = [False] * ((n-i*i - 1)//(2*i) + 1)
        return [2*i + 1 for i in range(1, n//2) if sieve[i]]

    odd_primes_above_13 = odd_primes_below_n(1<<16)[5:]
    m = 8 * 3 * 5 * 7 * 11 * 13
    residues = [x for x in range(7, m, 8) if all([x % y != 0 for y in (3, 5, 7, 11, 13)])]
    sieve_info = [(p, pow(m%p, p-2, p)) for p in odd_primes_above_13]

    def rust_type_for_num(s):
        assert type(s) is int, 'type must be `int`, not {}'.format(type(s))

        for i in range(3, 7):
            i = 1 << i
            if s < (1 << i):
                return 'u{}'.format(i)
        raise ValueError('{} too large to be represented by any Rust primitive integer type.'.format(s))

    #
    # Call rustfmt to get a decently formatted output.
    #
    with subprocess.Popen(('rustfmt',),stdin=subprocess.PIPE,stdout=f,encoding='UTF-8') as proc:
        def p(s): print(s, file=proc.stdin)
        def print_obj(name, type_str, sequence):
            p('pub const {}: {} = {};\n\n'.format(name, type_str, sequence))

        def list_inner_type(sequence):
            m = max(sequence)
            if type(m) is int:
                return rust_type_for_num(m)
            elif type(m) is tuple:
                return str(tuple(map(list_inner_type, zip(*sequence)))).replace("'", '')
            else:
                assert False, "bad list element type"

        def print_list(name, sequence):
            if type(sequence) is int:
                print_obj(name, rust_type_for_num(sequence), sequence)
            elif type(sequence) is list:
                print_obj(name, '[{}; {}]'.format(list_inner_type(sequence), len(sequence)), sequence)

        p('''// GENERATED BY gen_primes.py, DO NOT EDIT!
//! This file contains various precomputed tables used by create_discriminant.rs.
//! It is generated by gen_primes.py.
//! To regenerate it, install Python 3 and rustfmt, then run
//!
//! ```sh
//! $ python3 gen_primes.py constants.rs
//! ```
//!
//! in this file’s containing directory.
//!
//! You can also select any other `.rs` file as the name of the output, but be careful: if it exists,
//! it will be silently overwritten!  The outputs should
//! be identical, modulo changes in `rustfmt` and Git’s changes to line endings.
#![cfg_attr(feature = "cargo-clippy", allow(clippy::unreadable_literal))]
#![forbid(unsafe_code)]
''')
        print_list('M', m)
        print_list('RESIDUES', residues)
        print_list('SIEVE_INFO', sieve_info)

    sys.exit(proc.returncode)

def _main():
    num_args = len(sys.argv) - 1
    if num_args > 1:
        print('Must have at most one argument: name of rust file to generate.', file=sys.stderr)
        sys.exit(1)
    elif num_args:
        output_file = sys.argv[1]
        if not output_file.endswith('.rs'):
            print('Output file name must end in .rs', file=sys.stderr)
            sys.exit(1)
        with open(output_file, 'wb') as f:
            generate(f)
    else:
        generate(sys.stdout)

_main()
